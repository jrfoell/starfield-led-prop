#include <MIDI.h>
#include <Adafruit_NeoPXL8.h>

/* BEGIN MIDI Settings */

/**
 * MIDI Notes - Make sure they don't interfere with the metronome
 * https://github.com/jrfoell/visual-metronome/blob/main/visual-metronome.ino
 * If more notes are needed, both could restrict to specific midi channels raather than MIDI_CHANNEL_OMNI
 */
#define NOTE_A0 21
#define NOTE_B0 23
#define NOTE_C1 24
#define NOTE_D1 26
#define NOTE_E1 28
#define NOTE_F1 29
#define NOTE_G1 31
#define NOTE_A1 33
#define NOTE_B1 35
#define NOTE_C2 36
#define NOTE_D2 38
#define NOTE_E2 40
#define NOTE_F2 41
#define NOTE_G2 43
#define NOTE_A2 45
#define NOTE_B2 47

// Override the default MIDI baudrate for FeatherWing
struct CustomBaudRateSettings : public MIDI_NAMESPACE::DefaultSerialSettings {
  static const long BaudRate = 31250;
};

// Leonardo, Due and other USB boards use Serial1 by default.
MIDI_NAMESPACE::SerialMIDI<HardwareSerial, CustomBaudRateSettings> serialMIDI(Serial1);
MIDI_NAMESPACE::MidiInterface<MIDI_NAMESPACE::SerialMIDI<HardwareSerial, CustomBaudRateSettings>> MIDI((MIDI_NAMESPACE::SerialMIDI<HardwareSerial, CustomBaudRateSettings>&)serialMIDI);

/* END MIDI Settings */

#define FULL_WIDTH 80
#define PANEL_HEIGHT 56
#define PANEL_WIDTH 16

/* BEGIN NeoPXL8 Settings */
#define NUM_LEDS    896     // NeoPixels PER PANEL, total number is 8X this!
#define NUM_PIXELS (FULL_WIDTH * PANEL_HEIGHT)
#define PIXEL_BYTES (NUM_PIXELS / 8)
#define COLOR_ORDER NEO_GRB // NeoPixel color format (see Adafruit_NeoPixel)
#define LED_BLACK		0

// Here's a pinout that works with the Feather M4 (not M0) w/NeoPXL8 M4
// FeatherWing in the factory configuration:
int8_t pins[8] = { 13, 12, 11, 10, SCK, 5, 9, 6 };

// Here's the global constructor as explained near the start:
Adafruit_NeoPXL8 leds(NUM_LEDS, pins, COLOR_ORDER);


/* NeoPXL8 Rain Settings */
// For the Rain demo we use a table of 8 hues, one for each strand of pixels:
static uint8_t colors[8][3] = {
  255,   0,   0, // Row 0: Red
  255, 160,   0, // Row 1: Orange
  255, 255,   0, // Row 2: Yellow
    0, 255,   0, // Row 3: Green
    0, 255, 255, // Row 4: Cyan
    0,   0, 255, // Row 5: Blue
  192,   0, 255, // Row 6: Purple
  255,   0, 255  // Row 7: Magenta
};
/* End NeoPXL8 Rain Settings */

// Max is 255, 32 is a conservative value
#define BRIGHTNESS 32
/* END NeoPXL8 Settings */

/* BEGIN Star Twinkle Settings */
#define STAR_MIN_BRIGHTNESS 10   // Minimum brightness when star is dimmest
#define STAR_MAX_BRIGHTNESS 100  // Maximum brightness when star is brightest
#define TWINKLE_SPEED 8          // Lower = faster twinkling (divisor for millis)
/* END Star Twinkle Settings */

uint8_t animation = 0;

// greyscale image 56x80px
// Convert via https://javl.github.io/image2cpp/
// Rotate: 90, Draw Mode: Horizontal, Swap Bits: YES
// Manually reorder the odd rows

// https://www.shutterstock.com/image-vector/northern-hemisphere-high-detailed-star-map-2713195867
// 'northern-hemisphere-high-detaile-80x56'
static const uint8_t PROGMEM starfield[PIXEL_BYTES] = {
  // Panel 1
  0x00, 0x00, 0x00, 0x15, 0x10, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x40, 0x00, 0x10, 0x00, 0x00, 0x00, 0xaa, 
  0x29, 0x00, 0x00, 0x40, 0x25, 0x00, 0x00, 
  0x00, 0x02, 0x20, 0x05, 0x80, 0x02, 0x20, 
  0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x00, 0x00, 0x84, 0x00, 0x04, 
  0x00, 0x09, 0x20, 0x00, 0x05, 0x00, 0x00, 
  0x01, 0x01, 0x14, 0x10, 0x10, 0x80, 0x05, 
  0x02, 0x00, 0x04, 0x00, 0x00, 0x11, 0x80, 
  0x00, 0x29, 0x08, 0x04, 0x00, 0x00, 0x00, 
  0x00, 0x80, 0x08, 0x21, 0x29, 0x29, 0x20, 
  0x00, 0x36, 0x00, 0x91, 0x89, 0x02, 0x00, 
  0x40, 0x09, 0x00, 0x00, 0x2a, 0x00, 0x91, 
  0x9e, 0x24, 0x80, 0x40, 0x10, 0x00, 0x0a, 
  // Panel 2
  0x00, 0x00, 0x00, 0x00, 0x2a, 0x55, 0x42, 
  0x05, 0x05, 0x50, 0x00, 0x00, 0x15, 0x08, 
  0x0a, 0xa5, 0x00, 0x00, 0x00, 0x40, 0x00, 
  0x00, 0x09, 0x1b, 0x0a, 0x21, 0x01, 0x01, 
  0x00, 0x00, 0x20, 0x05, 0x40, 0x15, 0x00, 
  0x10, 0x15, 0x00, 0x00, 0x24, 0x20, 0x05, 
  0x00, 0x05, 0x24, 0x08, 0x00, 0x00, 0x20, 
  0x00, 0x00, 0x00, 0x08, 0x00, 0x05, 0x29, 
  0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
  0x00, 0x00, 0x00, 0x80, 0x00, 0x08, 0x22, 
  0x14, 0x00, 0x2a, 0x00, 0x40, 0x00, 0x04, 
  0x00, 0x01, 0x2a, 0x00, 0x00, 0x05, 0x00, 
  0x40, 0x00, 0x11, 0x00, 0x00, 0x28, 0x00, 
  0x02, 0x01, 0x00, 0x50, 0x00, 0x94, 0x00, 
  0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x51, 
  0x00, 0x45, 0x00, 0x00, 0x45, 0x00, 0x02, 
  // Panel 3
  0x11, 0x00, 0x90, 0x05, 0x00, 0xa0, 0x00, 
  0x05, 0x45, 0x05, 0x00, 0x00, 0x01, 0x63, 
  0x00, 0x11, 0x00, 0x00, 0x41, 0x08, 0x05, 
  0x04, 0x08, 0x40, 0x00, 0x89, 0x00, 0x00, 
  0x80, 0x40, 0x45, 0x00, 0x00, 0x01, 0x10, 
  0x00, 0x01, 0x00, 0x21, 0x40, 0x00, 0x00, 
  0x08, 0x10, 0x14, 0x04, 0x09, 0x05, 0x28, 
  0x01, 0x01, 0x80, 0x41, 0x00, 0x14, 0x00, 
  0x15, 0x09, 0x10, 0x10, 0x05, 0x95, 0x00, 
  0x11, 0x8a, 0x00, 0x15, 0x09, 0x52, 0x0a, 
  0x20, 0x10, 0x01, 0x00, 0x00, 0x00, 0x29, 
  0x02, 0x80, 0x09, 0x08, 0x00, 0x00, 0x80, 
  0x81, 0x00, 0x05, 0x00, 0x95, 0xaa, 0x80, 
  0x00, 0x04, 0x10, 0x01, 0x88, 0x00, 0x00, 
  0x28, 0x90, 0x21, 0x02, 0x00, 0x20, 0x01, 
  0x89, 0x02, 0x08, 0x41, 0x00, 0x00, 0x02, 
  // Panel 4
  0x08, 0x01, 0x00, 0x00, 0x02, 0x08, 0x04, 
  0x41, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
  0x41, 0x08, 0x00, 0x20, 0xa0, 0x00, 0x00, 
  0x14, 0x00, 0x01, 0x15, 0x00, 0x04, 0x20, 
  0xa0, 0x00, 0x00, 0x10, 0x00, 0x25, 0x0a, 
  0x00, 0x00, 0x28, 0x05, 0x20, 0x80, 0x00, 
  0x00, 0x00, 0xa0, 0x40, 0x20, 0x40, 0x08, 
  0x25, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0a, 
  0x80, 0x00, 0x02, 0x00, 0x49, 0x05, 0x00, 
  0x10, 0x00, 0x20, 0x20, 0x11, 0x00, 0x00, 
  0x09, 0x04, 0x00, 0x10, 0x90, 0x20, 0x00, 
  0x15, 0x4a, 0x41, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x20, 0x00, 0x41, 0x41, 0x51, 
  0x08, 0x40, 0x00, 0x20, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x08, 0x22, 0x00, 
  0x00, 0x00, 0x00, 0x08, 0x48, 0x10, 0x00, 
  // Panel 5
  0x08, 0x08, 0x02, 0x01, 0x80, 0x02, 0x00, 
  0x00, 0x50, 0x08, 0x0a, 0x20, 0x00, 0x20, 
  0x00, 0x15, 0x00, 0xb9, 0x20, 0x08, 0x0a, 
  0x00, 0x04, 0x00, 0x00, 0x10, 0x20, 0x00, 
  0x01, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x08, 0xa0, 0x00, 0x02, 
  0x40, 0x00, 0x00, 0x00, 0x5b, 0x05, 0x00, 
  0x04, 0x20, 0x02, 0x08, 0x10, 0x80, 0x00, 
  0x7b, 0x0f, 0x00, 0x20, 0x00, 0x00, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0xc3, 0x00, 0x20, 
  0x00, 0x11, 0x00, 0x00, 0x00, 0x0a, 0x00, 
  0x45, 0x80, 0x00, 0x01, 0x11, 0x05, 0x00, 
  0x00, 0x01, 0x80, 0x00, 0x80, 0x00, 0x00, 
  0x0a, 0x00, 0x2a, 0x00, 0x01, 0x80, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x20, 
  0x00, 0x00, 0x11, 0x02, 0x00, 0x01, 0x00,
};

static const uint8_t PROGMEM panel_setup[PIXEL_BYTES] = {
  // Panel 1
	0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  // Panel 2
	0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  // Panel 3
	0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  // Panel 4
	0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	// Panel 5
  0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80
};




//Byte val 2PI Cosine Wave, offset by 1 PI
//supports fast trig calcs and smooth LED fading/pulsing.
static const uint8_t PROGMEM cos_wave[256]  =
{0,0,0,0,1,1,1,2,2,3,4,5,6,6,8,9,10,11,12,14,15,17,18,20,22,23,25,27,29,31,33,35,38,40,42,
45,47,49,52,54,57,60,62,65,68,71,73,76,79,82,85,88,91,94,97,100,103,106,109,113,116,119,
122,125,128,131,135,138,141,144,147,150,153,156,159,162,165,168,171,174,177,180,183,186,
189,191,194,197,199,202,204,207,209,212,214,216,218,221,223,225,227,229,231,232,234,236,
238,239,241,242,243,245,246,247,248,249,250,251,252,252,253,253,254,254,255,255,255,255,
255,255,255,255,254,254,253,253,252,252,251,250,249,248,247,246,245,243,242,241,239,238,
236,234,232,231,229,227,225,223,221,218,216,214,212,209,207,204,202,199,197,194,191,189,
186,183,180,177,174,171,168,165,162,159,156,153,150,147,144,141,138,135,131,128,125,122,
119,116,113,109,106,103,100,97,94,91,88,85,82,79,76,73,71,68,65,62,60,57,54,52,49,47,45,
42,40,38,35,33,31,29,27,25,23,22,20,18,17,15,14,12,11,10,9,8,6,6,5,4,3,2,2,1,1,1,0,0,0,0
};
unsigned long frameCount=25500;  // arbitrary seed to calculate the three time displacement variables t,t2,t3

// -----------------------------------------------------------------------------
// This function will be automatically called when a NoteOn is received.
// It must be a void-returning function with the correct parameters,
// see documentation here:
// https://github.com/FortySevenEffects/arduino_midi_library/wiki/Using-Callbacks
void handleNoteOn(byte channel, byte pitch, byte velocity)
{
    // Do whatever you want when a note is pressed.

    // Try to keep your callbacks short (no delays ect)
    // otherwise it would slow down the loop() and have a bad impact
    // on real-time performance.
    //Serial.print("Note on: ");
    //Serial.println(pitch);
    
    switch(pitch) {
      case NOTE_A0:
        //Serial.println("Standby");
        animation = 0;
        break;

      case NOTE_B0:
        //Serial.println("Rain");
        animation = 1;
        break;

      case NOTE_C1:
        //Serial.println("Plasma");
        animation = 2;
        break;

      case NOTE_D1:
        //Serial.println("Stars");
        animation = 3;
        break;

     default:
        break;
    }
  }

// -----------------------------------------------------------------------------

void setup()
{
    // Serial setup
    //Serial.begin(115200);
    // Wait for the serial interface to be ready.
    //while (!Serial) ;
    //Serial.println("MIDI starfield leds");

    // Start NeoPXL8. If begin() returns false, either an invalid pin list
    // was provided, or requested too many pixels for available RAM.
    if (!leds.begin()) {
      // Blink the onboard LED if that happens.
      pinMode(LED_BUILTIN, OUTPUT);
      for (;;) digitalWrite(LED_BUILTIN, (millis() / 500) & 1);
    }

    // Otherwise, NeoPXL8 is now running, we can continue.
    //Serial.print("Setting brightness to ");
    //Serial.println(BRIGHTNESS);
    leds.setBrightness(BRIGHTNESS); // Tone it down, NeoPixels are BRIGHT!

    // Cycle all pixels red/green/blue on startup. If you see a different
    // sequence, COLOR_ORDER doesn't match your particular NeoPixel type.
    // If you get a jumble of colors, you're using RGBW NeoPixels with an
    // RGB order. Try different COLOR_ORDER values until code and hardware
    // are in harmony.
    for (uint32_t color = 0xFF0000; color > 0; color >>= 8) {
      leds.fill(color);
      leds.show();
      delay(1000);
    }

    // Light each strip in sequence. This helps verify the mapping of pins to
    // a physical LED installation. If strips flash out of sequence, you can
    // either re-wire, or just change the order of the pins[] array.
    for (int i=0; i<8; i++) {
      if (pins && (pins[i] < 0)) continue; // No pixels on this pin
      leds.fill(0);
      uint32_t color = leds.Color(colors[i][0], colors[i][1], colors[i][2]);
      leds.fill(color, i * NUM_LEDS, NUM_LEDS);
      leds.show();
      delay(300);
    }

    // MIDI Setup
    // Connect the handler function(s) to the library,
    MIDI.setHandleNoteOn(handleNoteOn);  // Put only the name of the function

    // Initiate MIDI communications, listen to all channels
    MIDI.begin(MIDI_CHANNEL_OMNI);
}

void loop()
{
    // Call MIDI.read the fastest you can for real-time performance of MIDI thru.
    MIDI.read();
    // There is no need to check if there are messages incoming
    // if they are bound to a Callback function.
    // The attached method will be called automatically
    // when the corresponding message has been received.

    // Do LED stuff every cycle.
    animate();
}

void animate() {
    switch(animation) {
      case 0:
        animateSetup();
        break;

      case 1:
        animateBlackout();
        break;

      case 2:
        animateRain();
        break;

      case 3:
        animatePlasma();
        break;

      case 4:
        animateStars();
        break;

      default:
        break;
    }
}

void animateBlackout() {
  leds.clear();
  leds.show();
}

void animateSetup() {
  uint16_t pixel = 0;
  for(int byte=0; byte<PIXEL_BYTES; byte++) {
    unsigned char pixel_byte = pgm_read_byte_near(panel_setup + byte);
    for(int bit=0; bit<8; bit++) {
      unsigned char bit_value = pixel_byte & 0x01;
      pixel_byte = pixel_byte >> 1;
      if(bit_value == 1) {
        leds.setPixelColor(pixel, leds.Color(255, 255, 255));
      } else {
        leds.setPixelColor(pixel, 0);
      }
      pixel++;
    }
  }
  leds.show();
}

void animateRain() {
  uint32_t now = millis(); // Get time once at start of each frame
  for(uint8_t r=0; r<8; r++) { // For each panel...
    for(int p=0; p<NUM_LEDS; p++) { // For each pixel of panel...
      leds.setPixelColor(r * NUM_LEDS + p, calcRain(now, r, p));
    }
  }
  leds.show();
}

// Given current time in milliseconds, row number (0-7) and pixel number
// along row (0 - (NUM_LEDS-1)), first calculate brightness (b) of pixel,
// then multiply row color by this and run it through NeoPixel libraryâ€™s
// gamma-correction table.
uint32_t calcRain(uint32_t now, uint8_t row, int pixelNum) {
  uint8_t frame = now / 4; // uint8_t rolls over for a 0-255 range
  uint16_t b = 256 - ((frame - row * 32 + pixelNum * 256 / NUM_LEDS) & 0xFF);
  return leds.Color(leds.gamma8((colors[row][0] * b) >> 8),
                    leds.gamma8((colors[row][1] * b) >> 8),
                    leds.gamma8((colors[row][2] * b) >> 8));
}

void animatePlasma() {
  frameCount++ ;
  uint16_t t = fastCosineCalc((42 * frameCount)/300);  //time displacement - fiddle with these til it looks good...
  uint16_t t2 = fastCosineCalc((35 * frameCount)/300);
  uint16_t t3 = fastCosineCalc((38 * frameCount)/300);

  for (uint8_t y = 0; y < PANEL_HEIGHT; y++) {
    int left2Right, pixelIndex;
    if (((y % (PANEL_HEIGHT/8)) & 1) == 0) {
      left2Right = 1;
      pixelIndex = y * FULL_WIDTH;
    } else {
      left2Right = -1;
      pixelIndex = (y + 1) * FULL_WIDTH - 1;
    }
    for (uint8_t x = 0; x < FULL_WIDTH; x++) {
      //Calculate 3 seperate plasma waves, one for each color channel
      uint8_t r = fastCosineCalc(((x << 3) + (t >> 1) + fastCosineCalc((t2 + (y << 3)))));
      uint8_t g = fastCosineCalc(((y << 3) + t + fastCosineCalc(((t3 >> 2) + (x << 3)))));
      uint8_t b = fastCosineCalc(((y << 3) + t2 + fastCosineCalc((t + x + (g >> 2)))));
      leds.setPixelColor(pixelIndex, leds.gamma32((r << 16) | (g << 8) | b));
    	pixelIndex += left2Right;
    }
  }
  leds.show();
}

inline uint8_t fastCosineCalc( uint16_t preWrapVal) {
  return (pgm_read_byte_near(cos_wave + (preWrapVal & 255)));
}

void animateStars() {
  uint32_t now = millis();
  uint16_t pixel = 0;
  for(int byte=0; byte<PIXEL_BYTES; byte++) { // For each byte in starfield
    unsigned char pixel_byte = pgm_read_byte_near(starfield + byte);
    for(int bit=0; bit<8; bit++) {
      unsigned char bit_value = pixel_byte & 0x01;
      pixel_byte = pixel_byte >> 1;
      if(bit_value == 1) {
        // Calculate unique twinkle phase for this star based on pixel position
        uint16_t phase = (now / TWINKLE_SPEED) + (pixel * 37); // 37 is prime for good distribution
        uint8_t wave = fastCosineCalc(phase);
        // Scale wave (0-255) to brightness range
        uint8_t brightness = STAR_MIN_BRIGHTNESS + ((wave * (STAR_MAX_BRIGHTNESS - STAR_MIN_BRIGHTNESS)) >> 8);
        leds.setPixelColor(pixel, leds.Color(brightness, brightness, brightness));
      } else {
        leds.setPixelColor(pixel, 0);
      }
      pixel++;
    }
  }
  leds.show();
}