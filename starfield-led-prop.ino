#include <MIDI.h>
#include <Adafruit_NeoPXL8.h>

/* BEGIN MIDI Settings */

/**
 * MIDI Notes - Make sure they don't interfere with the metronome
 * https://github.com/jrfoell/visual-metronome/blob/main/visual-metronome.ino
 * If more notes are needed, both could restrict to specific midi channels raather than MIDI_CHANNEL_OMNI
 */
#define NOTE_C0 24
#define NOTE_D0 26
#define NOTE_E0 28
#define NOTE_F0 29
#define NOTE_G0 31
#define NOTE_A0 33
#define NOTE_B0 35
#define NOTE_C1 36
#define NOTE_D1 38
#define NOTE_E1 40
#define NOTE_F1 41
#define NOTE_G1 43
#define NOTE_A1 45
#define NOTE_B1 47

// Override the default MIDI baudrate for FeatherWing
struct CustomBaudRateSettings : public MIDI_NAMESPACE::DefaultSerialSettings {
  static const long BaudRate = 31250;
};

// Leonardo, Due and other USB boards use Serial1 by default.
MIDI_NAMESPACE::SerialMIDI<HardwareSerial, CustomBaudRateSettings> serialMIDI(Serial1);
MIDI_NAMESPACE::MidiInterface<MIDI_NAMESPACE::SerialMIDI<HardwareSerial, CustomBaudRateSettings>> MIDI((MIDI_NAMESPACE::SerialMIDI<HardwareSerial, CustomBaudRateSettings>&)serialMIDI);

/* END MIDI Settings */

#define FULL_WIDTH 80
#define PANEL_HEIGHT 56
#define PANEL_WIDTH 16

/* BEGIN NeoPXL8 Settings */
#define NUM_LEDS    896     // NeoPixels PER PANEL, total number is 8X this!
#define NUM_PIXELS (FULL_WIDTH * PANEL_HEIGHT)
#define PIXEL_BYTES (NUM_PIXELS / 8)
#define COLOR_ORDER NEO_GRB // NeoPixel color format (see Adafruit_NeoPixel)
#define LED_BLACK		0

// Here's a pinout that works with the Feather M4 (not M0) w/NeoPXL8 M4
// FeatherWing in the factory configuration:
int8_t pins[8] = { 13, 12, 11, 10, SCK, 5, 9, 6 };

// Here's the global constructor as explained near the start:
Adafruit_NeoPXL8 leds(NUM_LEDS, pins, COLOR_ORDER);


/* NeoPXL8 Rain Settings */
// For the Rain demo we use a table of 8 hues, one for each strand of pixels:
static uint8_t colors[8][3] = {
  255,   0,   0, // Row 0: Red
  255, 160,   0, // Row 1: Orange
  255, 255,   0, // Row 2: Yellow
    0, 255,   0, // Row 3: Green
    0, 255, 255, // Row 4: Cyan
    0,   0, 255, // Row 5: Blue
  192,   0, 255, // Row 6: Purple
  255,   0, 255  // Row 7: Magenta
};
/* End NeoPXL8 Rain Settings */

// Max is 255, 32 is a conservative value
#define BRIGHTNESS 32
/* END NeoPXL8 Settings */

/* BEGIN Star Twinkle Settings */
#define STAR_MIN_BRIGHTNESS 10   // Minimum brightness when star is dimmest
#define STAR_MAX_BRIGHTNESS 100  // Maximum brightness when star is brightest
#define TWINKLE_SPEED 8          // Lower = faster twinkling (divisor for millis)
/* END Star Twinkle Settings */

uint8_t animation = 0;

// Collapse animation state
uint32_t collapseStartTime = 0;
bool collapseInitialized = false;
#define COLLAPSE_DURATION 2000  // Animation duration in ms

// Explode animation state
uint32_t explodeStartTime = 0;
bool explodeInitialized = false;
#define EXPLODE_DURATION 2000  // Animation duration in ms

// Scatter animation state
uint32_t scatterStartTime = 0;
bool scatterInitialized = false;
#define SCATTER_DURATION 2000  // Animation duration in ms

// Gimp: greyscale image 56x80px
// Convert via local fork of image2cpp file:///Users/mbiwinds/Documents/Arduino/image2cpp/index.html
// Background: Black, Brightness threshold: 10, Rotate: 90, Draw Mode: Horizontal, Swap Bits: YES, ZigZag: YES

// https://www.shutterstock.com/image-vector/northern-hemisphere-high-detailed-star-map-2713195867
// 'northern-hemisphere-high-detaile-80x56'
const unsigned char starfield [] PROGMEM = {
	0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x10, 
	0x02, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x02, 0x00, 0x30, 0x00, 0x00, 0x1e, 
	0x20, 0x08, 0x00, 0x40, 0x11, 0x00, 0x30, 0x30, 0xa0, 0x00, 0x06, 0x04, 0x6c, 0x03, 0x00, 0x00, 
	0x09, 0x60, 0x00, 0x08, 0xfc, 0x18, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 
	0x30, 0x40, 0x00, 0x40, 0x00, 0x18, 0x02, 0xc2, 0x00, 0x00, 0x3c, 0x09, 0x08, 0x00, 0x10, 0x00, 
	0x30, 0x00, 0x00, 0x04, 0x00, 0x00, 0x70, 0x0c, 0x0f, 0x00, 0x00, 0x00, 0x88, 0xcc, 0x00, 0x80, 
	0x00, 0xc0, 0x03, 0x00, 0x01, 0x12, 0x32, 0x10, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x20, 0x00, 
	0x20, 0x84, 0xc1, 0xc3, 0x01, 0x00, 0x00, 0x18, 0x00, 0x80, 0x25, 0x02, 0x00, 0x00, 0x01, 0xa0, 
	0x82, 0x30, 0x00, 0x67, 0x58, 0x02, 0x02, 0x04, 0xb0, 0x01, 0x05, 0x00, 0x00, 0x00, 0x80, 0x11, 
	0x00, 0x00, 0x00, 0xc2, 0x06, 0x84, 0x81, 0x14, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x60, 
	0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x18, 0x00, 0x14, 0x00, 
	0x00, 0x00, 0x06, 0x5e, 0x00, 0x00, 0x00, 0xc0, 0x1c, 0x00, 0x00, 0x00, 0x80, 0x05, 0x00, 0x00, 
	0xf0, 0x01, 0xc3, 0x10, 0x08, 0x02, 0x04, 0x83, 0x01, 0x00, 0x00, 0x20, 0x00, 0x80, 0x21, 0x20, 
	0x40, 0x00, 0x08, 0x04, 0x00, 0x07, 0x0e, 0x03, 0x00, 0x61, 0xc0, 0x00, 0x08, 0x00, 0x0a, 0x60, 
	0x06, 0x30, 0x18, 0x01, 0x00, 0x60, 0x00, 0x00, 0x40, 0x06, 0x06, 0x01, 0x06, 0x06, 0x30, 0x01, 
	0x98, 0x04, 0x62, 0x68, 0x00, 0x01, 0x16, 0x40, 0x00, 0x00, 0x00, 0x06, 0x60, 0x08, 0x06, 0xc2, 
	0x90, 0x04, 0x00, 0x00, 0x00, 0x08, 0x03, 0x60, 0x02, 0x00, 0x60, 0x40, 0x01, 0x08, 0x20, 0x00, 
	0x00, 0x40, 0x30, 0x10, 0x18, 0x00, 0x00, 0x06, 0x18, 0x02, 0x00, 0x18, 0x00, 0xe0, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x16, 0x18, 0x01, 0x0a, 0x06, 0x08, 0x00, 0x00, 0x00, 0xc0, 0x66, 0x00, 
	0x30, 0x00, 0x60, 0x80, 0x60, 0x0e, 0x02, 0x00, 0x00, 0x6f, 0x00, 0x60, 0xc4, 0x00, 0x11, 0xc1, 
	0x00, 0x06, 0x30, 0x00, 0xc0, 0x08, 0x00, 0x24, 0x00, 0x80, 0x20, 0x00, 0x00, 0x00, 0x46, 0x1c, 
	0x0c, 0x20, 0x06, 0x10, 0x16, 0x00, 0x01, 0x00, 0x00, 0x3c, 0x08, 0x80, 0x64, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x31, 0x00, 0x40, 0x00, 0x70, 0x00, 0x04, 0x35, 0x00, 0x80, 0x80, 0x41, 0xa0, 
	0x80, 0x98, 0x00, 0x00, 0xac, 0x01, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x5c, 
	0x10, 0x02, 0x04, 0x80, 0x20, 0x80, 0x80, 0x01, 0x80, 0x01, 0x00, 0x06, 0x00, 0x38, 0x00, 0x00, 
	0x19, 0x80, 0x01, 0x00, 0x00, 0x00, 0xb0, 0x01, 0x80, 0x00, 0x81, 0x8c, 0x31, 0x60, 0x70, 0x01, 
	0xd4, 0x18, 0x00, 0x00, 0x00, 0x26, 0x02, 0x00, 0x80, 0x01, 0x24, 0x04, 0x08, 0x00, 0x00, 0x88, 
	0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x20, 0x00, 0x38, 0xc0, 0x12, 0x83, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x0a, 0xcc, 0x04, 0x02, 0x00, 0x0e, 0x28, 0x00, 0x00, 0x04, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x10, 0x80, 0x24, 0x84, 0x01, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x08, 
	0x00, 0x80, 0x21, 0x00, 0x40, 0x34, 0x0c, 0x00, 0x60, 0x00, 0x00, 0x06, 0x00, 0x08, 0x80, 0x13, 
	0x10, 0x88, 0x60, 0x01, 0xc0, 0x01, 0x40, 0xb0, 0x08, 0x00, 0x80, 0x81, 0x02, 0x00, 0x10, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x14, 0x08, 0x00, 0x02, 0x80, 0x00, 0x00, 0x07, 0x80, 
	0x01, 0x83, 0x01, 0x18, 0x04, 0x08, 0xc0, 0x81, 0x01, 0xf0, 0x03, 0x40, 0x08, 0x00, 0x0d, 0x00, 
	0x00, 0x00, 0xc4, 0x30, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x20, 0x80, 0x11, 0x18, 0x00, 0x01
};

// 'star-prop-setup-screen', 56x80px
const unsigned char panel_setup [] PROGMEM = {
	0xfd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x3d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0xa4, 0xe5, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x25, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0xa4, 0xfd, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0xe1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0xfd, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0xe5, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0xa4, 0x3d, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80
};

// 'outer-wilds-star-80x56', 56x80px
const unsigned char outer_wilds [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x00, 0x00, 0x06, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x30, 0x00, 0x00, 0x18, 0x00, 0x10, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x00, 0x60, 0x00, 0x10, 0x00, 0x18, 
	0x00, 0x00, 0x30, 0x00, 0x0c, 0x00, 0x07, 0x00, 0x00, 0xc0, 0x00, 0x3c, 0x00, 0x06, 0x00, 0x00, 
	0xc0, 0x80, 0x3c, 0x80, 0x01, 0x00, 0x00, 0x00, 0x23, 0x3c, 0x81, 0x01, 0x00, 0x00, 0x00, 0x83, 
	0x3f, 0x66, 0x00, 0x00, 0x00, 0x00, 0x6c, 0xfc, 0xf9, 0x00, 0x00, 0x00, 0x40, 0xbe, 0x7f, 0x1b, 
	0x00, 0x00, 0x00, 0x00, 0xb8, 0xff, 0x3f, 0x03, 0x00, 0x00, 0x80, 0xf9, 0xff, 0x0f, 0x00, 0x00, 
	0x00, 0x80, 0xe1, 0xff, 0xff, 0x00, 0x00, 0x00, 0x3c, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 
	0xfc, 0xff, 0xbf, 0x0f, 0x00, 0x00, 0x80, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 
	0xff, 0x01, 0x00, 0xfc, 0xff, 0xff, 0xe1, 0x0f, 0x00, 0x00, 0x80, 0xff, 0xff, 0x87, 0xff, 0xff, 
	0x3f, 0x00, 0xc0, 0xff, 0xe1, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xfb, 0xc7, 0xff, 0x01, 0x00, 0x00, 
	0xe0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x00, 0x00, 0x00, 0xc0, 0xfb, 
	0xff, 0xef, 0x01, 0x00, 0x00, 0xe0, 0xf1, 0xff, 0x3f, 0x07, 0x00, 0x00, 0x78, 0xee, 0xff, 0x1f, 
	0x1e, 0x00, 0x00, 0x1e, 0xec, 0xff, 0xe3, 0x38, 0x00, 0x00, 0x86, 0xe3, 0xff, 0x6f, 0xe0, 0x01, 
	0xc0, 0x01, 0x38, 0xff, 0x87, 0x03, 0x00, 0x00, 0xe0, 0xa0, 0x9e, 0x19, 0x00, 0x0e, 0x1c, 0x00, 
	0x8c, 0x7d, 0x00, 0x0e, 0x00, 0x00, 0x30, 0x00, 0x3e, 0x63, 0x00, 0xe0, 0x01, 0x00, 0xc6, 0x74, 
	0x00, 0x18, 0x00, 0x00, 0x0c, 0x00, 0x0e, 0xc6, 0x00, 0x00, 0x00, 0x80, 0x61, 0x70, 0x00, 0x60, 
	0x00, 0x00, 0x03, 0x00, 0x0e, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x30, 0x70, 0x00, 0x80, 0x01, 0xc0, 
	0x00, 0x00, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x08, 0x30, 0x00, 0x00, 0x06, 0x30, 0x00, 0x00, 
	0x0c, 0x30, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x18, 0x0c, 0x00, 0x00, 0x04, 0x60, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x60, 0x03, 0x00, 0x00, 0x04, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x80, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//Byte val 2PI Cosine Wave, offset by 1 PI
//supports fast trig calcs and smooth LED fading/pulsing.
static const uint8_t PROGMEM cos_wave[256]  =
{0,0,0,0,1,1,1,2,2,3,4,5,6,6,8,9,10,11,12,14,15,17,18,20,22,23,25,27,29,31,33,35,38,40,42,
45,47,49,52,54,57,60,62,65,68,71,73,76,79,82,85,88,91,94,97,100,103,106,109,113,116,119,
122,125,128,131,135,138,141,144,147,150,153,156,159,162,165,168,171,174,177,180,183,186,
189,191,194,197,199,202,204,207,209,212,214,216,218,221,223,225,227,229,231,232,234,236,
238,239,241,242,243,245,246,247,248,249,250,251,252,252,253,253,254,254,255,255,255,255,
255,255,255,255,254,254,253,253,252,252,251,250,249,248,247,246,245,243,242,241,239,238,
236,234,232,231,229,227,225,223,221,218,216,214,212,209,207,204,202,199,197,194,191,189,
186,183,180,177,174,171,168,165,162,159,156,153,150,147,144,141,138,135,131,128,125,122,
119,116,113,109,106,103,100,97,94,91,88,85,82,79,76,73,71,68,65,62,60,57,54,52,49,47,45,
42,40,38,35,33,31,29,27,25,23,22,20,18,17,15,14,12,11,10,9,8,6,6,5,4,3,2,2,1,1,1,0,0,0,0
};
unsigned long frameCount=25500;  // arbitrary seed to calculate the three time displacement variables t,t2,t3

// -----------------------------------------------------------------------------
// This function will be automatically called when a NoteOn is received.
// It must be a void-returning function with the correct parameters,
// see documentation here:
// https://github.com/FortySevenEffects/arduino_midi_library/wiki/Using-Callbacks
void handleNoteOn(byte channel, byte pitch, byte velocity)
{
    // Do whatever you want when a note is pressed.

    // Try to keep your callbacks short (no delays ect)
    // otherwise it would slow down the loop() and have a bad impact
    // on real-time performance.
    Serial.print("Note on: ");
    Serial.println(pitch);
    
    switch(pitch) {
      case NOTE_C0:
        Serial.println("Standby");
        animation = 0;
        break;

      case NOTE_D0:
        Serial.println("Blackout");
        animation = 1;
        break;

      case NOTE_E0:
        Serial.println("Stars");
        animation = 2;
        break;

      case NOTE_F0:
        Serial.println("These");
        animation = 3;
        break;

      case NOTE_G0:
        Serial.println("Collapse");
        collapseInitialized = false;  // Reset animation state
        animation = 4;
        break;

      case NOTE_A0:
        Serial.println("Explode");
        explodeInitialized = false;  // Reset animation state
        animation = 5;
        break;

      case NOTE_B0:
        Serial.println("Scatter");
        scatterInitialized = false;  // Reset animation state
        animation = 6;
        break;

      case NOTE_C1:
        Serial.println("Constellation");
        animation = 7;
        break;

      case NOTE_A1:
        Serial.println("Rain");
        animation = 8;
        break;

      case NOTE_B1:
        Serial.println("Plasma");
        animation = 9;
        break;


     default:
        break;
    }
  }
// -----------------------------------------------------------------------------

void animate() {
    switch(animation) {
      case 0:
        animateSetup();
        break;

      case 1:
        animateBlackout();
        break;

      case 2:
        animateStars();
        break;

      case 3:
        animateThese();
        break;

      case 4:
        animateCollapse();
        break;

      case 5:
        animateExplode();
        break;

      case 6:
        animateScatter();
        break;

      case 7:
        animateConstellation();
        break;

      case 8:
        animateRain();
        break;

      case 9:
        animatePlasma();
        break;

      default:
        break;
    }
}

void setup()
{
    // Serial setup
    Serial.begin(115200);
    // Wait for the serial interface to be ready.
    while (!Serial) ;
    Serial.println("MIDI starfield leds");

    // Start NeoPXL8. If begin() returns false, either an invalid pin list
    // was provided, or requested too many pixels for available RAM.
    if (!leds.begin()) {
      // Blink the onboard LED if that happens.
      pinMode(LED_BUILTIN, OUTPUT);
      for (;;) digitalWrite(LED_BUILTIN, (millis() / 500) & 1);
    }

    // Otherwise, NeoPXL8 is now running, we can continue.
    //Serial.print("Setting brightness to ");
    //Serial.println(BRIGHTNESS);
    leds.setBrightness(BRIGHTNESS); // Tone it down, NeoPixels are BRIGHT!

    // Cycle all pixels red/green/blue on startup. If you see a different
    // sequence, COLOR_ORDER doesn't match your particular NeoPixel type.
    // If you get a jumble of colors, you're using RGBW NeoPixels with an
    // RGB order. Try different COLOR_ORDER values until code and hardware
    // are in harmony.
    for (uint32_t color = 0xFF0000; color > 0; color >>= 8) {
      leds.fill(color);
      leds.show();
      delay(1000);
    }

    // Light each strip in sequence. This helps verify the mapping of pins to
    // a physical LED installation. If strips flash out of sequence, you can
    // either re-wire, or just change the order of the pins[] array.
    for (int i=0; i<8; i++) {
      if (pins && (pins[i] < 0)) continue; // No pixels on this pin
      leds.fill(0);
      uint32_t color = leds.Color(colors[i][0], colors[i][1], colors[i][2]);
      leds.fill(color, i * NUM_LEDS, NUM_LEDS);
      leds.show();
      delay(300);
    }

    // MIDI Setup
    // Connect the handler function(s) to the library,
    MIDI.setHandleNoteOn(handleNoteOn);  // Put only the name of the function

    // Initiate MIDI communications, listen to all channels
    MIDI.begin(MIDI_CHANNEL_OMNI);
}

void loop()
{
    // Call MIDI.read the fastest you can for real-time performance of MIDI thru.
    MIDI.read();
    // There is no need to check if there are messages incoming
    // if they are bound to a Callback function.
    // The attached method will be called automatically
    // when the corresponding message has been received.

    // Do LED stuff every cycle.
    animate();
}

inline uint8_t fastCosineCalc( uint16_t preWrapVal) {
  return (pgm_read_byte_near(cos_wave + (preWrapVal & 255)));
}

// Convert (column, visual row) to pixel index, accounting for zigzag wiring
// Visual row 0 = top, row 55 = bottom
uint16_t getPixelIndex(uint8_t col, uint8_t row) {
  // Each column has PANEL_HEIGHT (56) pixels
  // Odd columns: pixel 0 is at bottom (row 55), pixel 55 is at top (row 0)
  // Even columns: pixel 0 is at top (row 0), pixel 55 is at bottom (row 55) - reversed
  if (col & 1) {
    // Odd column - reversed, so visual row 0 (top) maps to pixel index 55
    return col * PANEL_HEIGHT + (PANEL_HEIGHT - 1 - row);
  } else {
    // Even column - normal order, visual row maps directly to pixel index
    return col * PANEL_HEIGHT + row;
  }
}

void animateBlackout() {
  leds.clear();
  leds.show();
}

void animateSetup() {
  uint16_t pixel = 0;
  for(int byte=0; byte<PIXEL_BYTES; byte++) {
    unsigned char pixel_byte = pgm_read_byte_near(panel_setup + byte);
    for(int bit=0; bit<8; bit++) {
      unsigned char bit_value = pixel_byte & 0x01;
      pixel_byte = pixel_byte >> 1;
      if(bit_value == 1) {
        leds.setPixelColor(pixel, leds.Color(255, 255, 255));
      } else {
        leds.setPixelColor(pixel, 0);
      }
      pixel++;
    }
  }
  leds.show();
}

void animateStars() {
  uint32_t now = millis();
  uint16_t pixel = 0;
  for(int byte=0; byte<PIXEL_BYTES; byte++) { // For each byte in starfield
    unsigned char pixel_byte = pgm_read_byte_near(starfield + byte);
    for(int bit=0; bit<8; bit++) {
      unsigned char bit_value = pixel_byte & 0x01;
      pixel_byte = pixel_byte >> 1;
      if(bit_value == 1) {
        // Calculate unique twinkle phase for this star based on pixel position
        uint16_t phase = (now / TWINKLE_SPEED) + (pixel * 37); // 37 is prime for good distribution
        uint8_t wave = fastCosineCalc(phase);
        // Scale wave (0-255) to brightness range
        uint8_t brightness = STAR_MIN_BRIGHTNESS + ((wave * (STAR_MAX_BRIGHTNESS - STAR_MIN_BRIGHTNESS)) >> 8);
        leds.setPixelColor(pixel, leds.Color(brightness, brightness, brightness));
      } else {
        leds.setPixelColor(pixel, 0);
      }
      pixel++;
    }
  }
  leds.show();
}

void animateThese() {
  uint32_t now = millis();
  
  // Calculate synchronized pulse phase (all pixels same phase)
  uint16_t phase = now / TWINKLE_SPEED;
  uint8_t wave = fastCosineCalc(phase);
  
  // Scale wave (0-255) to 50%-100% brightness range (128-255)
  uint8_t brightness = 128 + (wave >> 1);  // 128 + (0-127) = 128-255
  
  uint16_t pixel = 0;
  for(int byte=0; byte<PIXEL_BYTES; byte++) {
    unsigned char pixel_byte = pgm_read_byte_near(starfield + byte);
    for(int bit=0; bit<8; bit++) {
      unsigned char bit_value = pixel_byte & 0x01;
      pixel_byte = pixel_byte >> 1;
      if(bit_value == 1) {
        leds.setPixelColor(pixel, leds.Color(brightness, brightness, brightness));
      } else {
        leds.setPixelColor(pixel, 0);
      }
      pixel++;
    }
  }
  leds.show();
}

void animateCollapse() {
  uint32_t now = millis();
  
  // Initialize animation on first call
  if (!collapseInitialized) {
    collapseStartTime = now;
    collapseInitialized = true;
  }
  
  // Calculate animation progress (0.0 to 1.0, clamped)
  uint32_t elapsed = now - collapseStartTime;
  float progress = (float)elapsed / COLLAPSE_DURATION;
  if (progress > 1.0f) progress = 1.0f;
  
  // Clear all pixels first
  leds.clear();
  
  // Process each column
  for (uint8_t col = 0; col < FULL_WIDTH; col++) {
    // First pass: collect all lit star positions in this column
    uint8_t starRows[PANEL_HEIGHT];  // Original row positions of stars
    uint8_t starCount = 0;
    
    // Read the column from starfield bitmap
    // Data is column-major: column c starts at byte c * 7
    uint16_t byteOffset = col * 7;
    
    for (uint8_t row = 0; row < PANEL_HEIGHT; row++) {
      uint8_t byteIdx = row / 8;
      uint8_t bitIdx = row % 8;
      uint8_t pixel_byte = pgm_read_byte_near(starfield + byteOffset + byteIdx);
      
      if (pixel_byte & (1 << bitIdx)) {
        // This star is lit - record its original position
        starRows[starCount] = row;
        starCount++;
      }
    }
    
    // Second pass: calculate target positions and animate
    // Phase 1: Stars collapse toward bottom, stacking from row 0
    // Phase 2: All stars converge to row 0 (single star per column)
    for (uint8_t i = 0; i < starCount; i++) {
      uint8_t originalRow = starRows[i];
      uint8_t currentRow;
      
      if (progress <= 0.5f) {
        // Phase 1: stack at top (star i goes to row i)
        float phase1Progress = progress * 2.0f;  // Scale 0-0.5 to 0-1
        currentRow = (uint8_t)(originalRow + (i - originalRow) * phase1Progress + 0.5f);
      } else {
        // Phase 2: all converge to row 0
        float phase2Progress = (progress - 0.5f) * 2.0f;  // Scale 0.5-1 to 0-1
        currentRow = (uint8_t)(i * (1.0f - phase2Progress) + 0.5f);
      }
      
      // Get pixel index accounting for zigzag wiring
      uint16_t pixelIdx = getPixelIndex(col, currentRow);
      
      // Set pixel with twinkling brightness
      uint16_t phase = (now / TWINKLE_SPEED) + (pixelIdx * 37);
      uint8_t wave = fastCosineCalc(phase);
      uint8_t brightness = STAR_MIN_BRIGHTNESS + ((wave * (STAR_MAX_BRIGHTNESS - STAR_MIN_BRIGHTNESS)) >> 8);
      leds.setPixelColor(pixelIdx, leds.Color(brightness, brightness, brightness));
    }
  }
  
  leds.show();
}

void animateExplode() {
  uint32_t now = millis();
  
  if (!explodeInitialized) {
    explodeStartTime = now;
    explodeInitialized = true;
  }
  
  uint32_t elapsed = now - explodeStartTime;
  float progress = (float)elapsed / EXPLODE_DURATION;
  if (progress > 1.0f) progress = 1.0f;
  
  // Center of display
  const float centerCol = FULL_WIDTH / 2.0f;   // 40
  const float centerRow = PANEL_HEIGHT / 2.0f; // 28
  
  // Max distance (corner to center)
  const float maxDist = sqrt(centerCol * centerCol + centerRow * centerRow);
  
  // Current reveal radius
  float revealRadius = progress * maxDist;
  
  leds.clear();
  
  for (uint8_t col = 0; col < FULL_WIDTH; col++) {
    uint16_t byteOffset = col * 7;
    
    for (uint8_t row = 0; row < PANEL_HEIGHT; row++) {
      uint8_t byteIdx = row / 8;
      uint8_t bitIdx = row % 8;
      uint8_t pixel_byte = pgm_read_byte_near(outer_wilds + byteOffset + byteIdx);
      
      if (pixel_byte & (1 << bitIdx)) {
        // Calculate distance from center
        float dx = col - centerCol;
        float dy = row - centerRow;
        float dist = sqrt(dx * dx + dy * dy);
        
        // Only show pixel if within reveal radius
        if (dist <= revealRadius) {
          uint16_t pixelIdx = getPixelIndex(col, row);
          
          // Twinkling brightness
          uint16_t phase = (now / TWINKLE_SPEED) + (pixelIdx * 37);
          uint8_t wave = fastCosineCalc(phase);
          uint8_t brightness = STAR_MIN_BRIGHTNESS + ((wave * (STAR_MAX_BRIGHTNESS - STAR_MIN_BRIGHTNESS)) >> 8);
          leds.setPixelColor(pixelIdx, leds.Color(brightness, brightness, brightness));
        }
      }
    }
  }
  
  leds.show();
}

void animateScatter() {
  uint32_t now = millis();
  
  if (!scatterInitialized) {
    scatterStartTime = now;
    scatterInitialized = true;
  }
  
  uint32_t elapsed = now - scatterStartTime;
  float progress = (float)elapsed / SCATTER_DURATION;
  if (progress > 1.0f) progress = 1.0f;
  
  leds.clear();
  
  for (uint8_t col = 0; col < FULL_WIDTH; col++) {
    uint16_t byteOffset = col * 7;
    
    for (uint8_t row = 0; row < PANEL_HEIGHT; row++) {
      uint8_t byteIdx = row / 8;
      uint8_t bitIdx = row % 8;
      
      uint8_t outerByte = pgm_read_byte_near(outer_wilds + byteOffset + byteIdx);
      uint8_t starByte = pgm_read_byte_near(starfield + byteOffset + byteIdx);
      
      bool inOuter = outerByte & (1 << bitIdx);
      bool inStar = starByte & (1 << bitIdx);
      
      if (inOuter || inStar) {
        uint16_t pixelIdx = getPixelIndex(col, row);
        uint8_t brightness;
        
        if (inOuter && inStar) {
          // Present in both - full twinkling brightness
          uint16_t phase = (now / TWINKLE_SPEED) + (pixelIdx * 37);
          uint8_t wave = fastCosineCalc(phase);
          brightness = STAR_MIN_BRIGHTNESS + ((wave * (STAR_MAX_BRIGHTNESS - STAR_MIN_BRIGHTNESS)) >> 8);
        } else if (inOuter) {
          // Only in outer_wilds - fade out
          brightness = (uint8_t)(STAR_MAX_BRIGHTNESS * (1.0f - progress));
        } else {
          // Only in starfield - fade in
          brightness = (uint8_t)(STAR_MAX_BRIGHTNESS * progress);
        }
        
        if (brightness > 0) {
          leds.setPixelColor(pixelIdx, leds.Color(brightness, brightness, brightness));
        }
      }
    }
  }
  
  leds.show();
}

void animateConstellation() {

}

void animateRain() {
  uint32_t now = millis(); // Get time once at start of each frame
  for(uint8_t r=0; r<8; r++) { // For each panel...
    for(int p=0; p<NUM_LEDS; p++) { // For each pixel of panel...
      leds.setPixelColor(r * NUM_LEDS + p, calcRain(now, r, p));
    }
  }
  leds.show();
}

// Given current time in milliseconds, row number (0-7) and pixel number
// along row (0 - (NUM_LEDS-1)), first calculate brightness (b) of pixel,
// then multiply row color by this and run it through NeoPixel libraryâ€™s
// gamma-correction table.
uint32_t calcRain(uint32_t now, uint8_t row, int pixelNum) {
  uint8_t frame = now / 4; // uint8_t rolls over for a 0-255 range
  uint16_t b = 256 - ((frame - row * 32 + pixelNum * 256 / NUM_LEDS) & 0xFF);
  return leds.Color(leds.gamma8((colors[row][0] * b) >> 8),
                    leds.gamma8((colors[row][1] * b) >> 8),
                    leds.gamma8((colors[row][2] * b) >> 8));
}

void animatePlasma() {
  frameCount++ ;
  uint16_t t = fastCosineCalc((42 * frameCount)/300);  //time displacement - fiddle with these til it looks good...
  uint16_t t2 = fastCosineCalc((35 * frameCount)/300);
  uint16_t t3 = fastCosineCalc((38 * frameCount)/300);

  for (uint8_t y = 0; y < PANEL_HEIGHT; y++) {
    int left2Right, pixelIndex;
    if (((y % (PANEL_HEIGHT/8)) & 1) == 0) {
      left2Right = 1;
      pixelIndex = y * FULL_WIDTH;
    } else {
      left2Right = -1;
      pixelIndex = (y + 1) * FULL_WIDTH - 1;
    }
    for (uint8_t x = 0; x < FULL_WIDTH; x++) {
      //Calculate 3 seperate plasma waves, one for each color channel
      uint8_t r = fastCosineCalc(((x << 3) + (t >> 1) + fastCosineCalc((t2 + (y << 3)))));
      uint8_t g = fastCosineCalc(((y << 3) + t + fastCosineCalc(((t3 >> 2) + (x << 3)))));
      uint8_t b = fastCosineCalc(((y << 3) + t2 + fastCosineCalc((t + x + (g >> 2)))));
      leds.setPixelColor(pixelIndex, leds.gamma32((r << 16) | (g << 8) | b));
    	pixelIndex += left2Right;
    }
  }
  leds.show();
}